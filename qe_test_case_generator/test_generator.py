"""
Test Generator for MDTD Test Engine
Converts LLM-generated tests into HTML5 web interface components
"""

import json
import uuid
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

from .config import Config

logger = logging.getLogger(__name__)


class TestGenerator:
    """Generates web-based test cases from LLM output"""

    def __init__(self, config: Config):
        self.config = config

    async def create_web_test_cases(
        self,
        generated_tests: Dict[str, Any],
        output_format: str = "html"
    ) -> Dict[str, Any]:
        """
        Convert LLM-generated tests into web-compatible test cases

        Args:
            generated_tests: Tests generated by LLM
            output_format: Output format (html, json, etc.)

        Returns:
            Web-compatible test cases
        """
        try:
            logger.info("Creating web test cases...")

            web_tests = {
                'test_suites': [],
                'metadata': {
                    'generated_at': datetime.now().isoformat(),
                    'format': output_format,
                    'total_functions': len(generated_tests.get('function_tests', [])),
                    'test_categories': self.config.test_categories
                }
            }

            # Process function tests
            for func_test in generated_tests.get('function_tests', []):
                test_suite = await self._create_function_test_suite(func_test)
                web_tests['test_suites'].append(test_suite)

            # Process integration tests
            if generated_tests.get('integration_tests'):
                integration_suite = await self._create_integration_test_suite(
                    generated_tests['integration_tests']
                )
                web_tests['test_suites'].append(integration_suite)

            # Process performance tests
            if generated_tests.get('performance_tests'):
                performance_suite = await self._create_performance_test_suite(
                    generated_tests['performance_tests']
                )
                web_tests['test_suites'].append(performance_suite)

            # Process security tests
            if generated_tests.get('security_tests'):
                security_suite = await self._create_security_test_suite(
                    generated_tests['security_tests']
                )
                web_tests['test_suites'].append(security_suite)

            logger.info("Created {} test suites".format(len(web_tests['test_suites'])))
            return web_tests

        except Exception as e:
            logger.error("Error creating web test cases: {}".format(str(e)))
            raise

    async def _create_function_test_suite(self, func_test: Dict) -> Dict:
        """Create a test suite for a specific function"""

        suite_id = str(uuid.uuid4())
        function_name = func_test.get('function', 'unknown')
        language = func_test.get('language', 'unknown')

        # Parse LLM-generated test code
        test_cases = await self._parse_llm_test_code(func_test.get('test_code', ''))

        # Create HTML5 form elements for each test case
        html_forms = []
        for test_case in test_cases:
            form_html = self._create_test_form(test_case, function_name)
            html_forms.append(form_html)

        return {
            'suite_id': suite_id,
            'suite_name': f"{function_name} Tests",
            'function_name': function_name,
            'language': language,
            'test_count': len(test_cases),
            'test_cases': test_cases,
            'html_forms': html_forms,
            'categories': list(set(tc.get('category', 'unknown') for tc in test_cases))
        }

    async def _parse_llm_test_code(self, test_code: str) -> List[Dict]:
        """Parse LLM-generated test code into structured test cases"""

        test_cases = []

        try:
            # Try to parse as JSON first
            parsed = json.loads(test_code)
            if isinstance(parsed, dict) and 'html_test_cases' in parsed:
                test_cases = parsed['html_test_cases']
            elif isinstance(parsed, list):
                test_cases = parsed
            else:
                test_cases = [parsed]

        except json.JSONDecodeError:
            # If not JSON, try to extract test information from text
            test_cases = self._extract_tests_from_text(test_code)

        # Ensure each test case has required fields
        for i, test_case in enumerate(test_cases):
            if not test_case.get('test_id'):
                test_case['test_id'] = str(uuid.uuid4())
            if not test_case.get('test_name'):
                test_case['test_name'] = f"Test Case {i+1}"
            if not test_case.get('category'):
                test_case['category'] = 'general'

        return test_cases

    def _extract_tests_from_text(self, text: str) -> List[Dict]:
        """Extract test information from unstructured text"""

        # Simple extraction - in a real implementation, this would be more sophisticated
        test_cases = []
        lines = text.split('\n')

        current_test = {}
        for line in lines:
            line = line.strip()

            if 'test' in line.lower() and ('case' in line.lower() or 'scenario' in line.lower()):
                if current_test:
                    test_cases.append(current_test)
                current_test = {
                    'test_id': str(uuid.uuid4()),
                    'test_name': line,
                    'category': 'extracted',
                    'description': line
                }
            elif line and current_test:
                if 'description' not in current_test:
                    current_test['description'] = line
                else:
                    current_test['description'] += ' ' + line

        if current_test:
            test_cases.append(current_test)

        # If no tests extracted, create a default one
        if not test_cases:
            test_cases.append({
                'test_id': str(uuid.uuid4()),
                'test_name': 'Default Test Case',
                'category': 'general',
                'description': text[:200] + '...' if len(text) > 200 else text
            })

        return test_cases

    def _create_test_form(self, test_case: Dict, function_name: str) -> Dict:
        """Create HTML5 form for a test case"""

        test_id = test_case.get('test_id', str(uuid.uuid4()))
        test_name = test_case.get('test_name', 'Test Case')
        category = test_case.get('category', 'general')

        # Generate appropriate input fields based on test category
        input_fields = self._generate_input_fields(test_case, function_name)

        # Create validation script
        validation_script = self._generate_validation_script(test_case, function_name)

        # Create the complete form HTML
        form_html = f"""
        <div class="test-case-container" id="test-{test_id}">
            <div class="test-header">
                <h3 class="test-title">{test_name}</h3>
                <span class="test-category badge badge-{category}">{category}</span>
            </div>
            
            <div class="test-description">
                <p>{test_case.get('description', 'No description available')}</p>
            </div>
            
            <form class="test-form" onsubmit="return executeTest('{test_id}', event)">
                <div class="input-section">
                    <h4>Test Inputs</h4>
                    {input_fields}
                </div>
                
                <div class="expected-output-section">
                    <h4>Expected Output</h4>
                    <div class="expected-output">
                        {test_case.get('expected_output', 'Expected result will be shown here')}
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button type="submit" class="btn btn-primary">Run Test</button>
                    <button type="button" class="btn btn-secondary" onclick="resetTest('{test_id}')">Reset</button>
                    <button type="button" class="btn btn-info" onclick="generateTestData('{test_id}')">Auto-fill</button>
                </div>
                
                <div class="test-results" id="results-{test_id}" style="display: none;">
                    <h4>Test Results</h4>
                    <div class="result-content"></div>
                </div>
            </form>
            
            <script type="text/javascript">
                {validation_script}
            </script>
        </div>
        """

        return {
            'test_id': test_id,
            'html': form_html,
            'validation_script': validation_script,
            'input_fields': input_fields,
            'metadata': {
                'function_name': function_name,
                'category': category,
                'test_name': test_name
            }
        }

    def _generate_input_fields(self, test_case: Dict, function_name: str) -> str:
        """Generate HTML5 input fields based on test case"""

        category = test_case.get('category', 'general')
        test_id = test_case.get('test_id')

        # Different input types based on test category
        if category == 'equivalence_partition':
            return self._create_equivalence_inputs(test_case, test_id)
        elif category == 'boundary_value':
            return self._create_boundary_inputs(test_case, test_id)
        elif category == 'error_condition':
            return self._create_error_inputs(test_case, test_id)
        elif category == 'performance':
            return self._create_performance_inputs(test_case, test_id)
        elif category == 'security':
            return self._create_security_inputs(test_case, test_id)
        else:
            return self._create_general_inputs(test_case, test_id)

    def _create_equivalence_inputs(self, test_case: Dict, test_id: str) -> str:
        """Create inputs for equivalence partitioning tests"""
        return f"""
        <div class="input-group">
            <label for="input1-{test_id}">Valid Input (Positive Case)</label>
            <input type="text" id="input1-{test_id}" name="input1" class="form-control" 
                   placeholder="Enter valid input value" required>
            <small class="form-text text-muted">Example: 5, 10, 100</small>
        </div>
        
        <div class="input-group">
            <label for="input2-{test_id}">Valid Input (Negative Case)</label>
            <input type="text" id="input2-{test_id}" name="input2" class="form-control" 
                   placeholder="Enter another valid input value">
            <small class="form-text text-muted">Example: -5, -10, -100</small>
        </div>
        
        <div class="input-group">
            <label for="input3-{test_id}">Edge Case Input</label>
            <input type="text" id="input3-{test_id}" name="input3" class="form-control" 
                   placeholder="Enter edge case value">
            <small class="form-text text-muted">Example: 0, empty string, null</small>
        </div>
        """

    def _create_boundary_inputs(self, test_case: Dict, test_id: str) -> str:
        """Create inputs for boundary value analysis tests"""
        return f"""
        <div class="input-group">
            <label for="min-{test_id}">Minimum Boundary Value</label>
            <input type="number" id="min-{test_id}" name="min_value" class="form-control" 
                   placeholder="Enter minimum value">
        </div>
        
        <div class="input-group">
            <label for="max-{test_id}">Maximum Boundary Value</label>
            <input type="number" id="max-{test_id}" name="max_value" class="form-control" 
                   placeholder="Enter maximum value">
        </div>
        
        <div class="input-group">
            <label for="just-below-{test_id}">Just Below Minimum</label>
            <input type="number" id="just-below-{test_id}" name="below_min" class="form-control" 
                   placeholder="Enter value just below minimum">
        </div>
        
        <div class="input-group">
            <label for="just-above-{test_id}">Just Above Maximum</label>
            <input type="number" id="just-above-{test_id}" name="above_max" class="form-control" 
                   placeholder="Enter value just above maximum">
        </div>
        """

    def _create_error_inputs(self, test_case: Dict, test_id: str) -> str:
        """Create inputs for error condition tests"""
        return f"""
        <div class="input-group">
            <label for="invalid-type-{test_id}">Invalid Type Input</label>
            <input type="text" id="invalid-type-{test_id}" name="invalid_type" class="form-control" 
                   placeholder="Enter invalid type (e.g., string when number expected)">
        </div>
        
        <div class="input-group">
            <label for="null-input-{test_id}">Null/Empty Input</label>
            <input type="text" id="null-input-{test_id}" name="null_input" class="form-control" 
                   placeholder="Leave empty or enter 'null'">
        </div>
        
        <div class="input-group">
            <label for="malformed-{test_id}">Malformed Input</label>
            <input type="text" id="malformed-{test_id}" name="malformed" class="form-control" 
                   placeholder="Enter malformed data">
        </div>
        """

    def _create_performance_inputs(self, test_case: Dict, test_id: str) -> str:
        """Create inputs for performance tests"""
        return f"""
        <div class="input-group">
            <label for="data-size-{test_id}">Data Size</label>
            <input type="range" id="data-size-{test_id}" name="data_size" class="form-control" 
                   min="1" max="10000" value="100" oninput="updateSizeDisplay('{test_id}')">
            <span id="size-display-{test_id}">100</span> items
        </div>
        
        <div class="input-group">
            <label for="iterations-{test_id}">Number of Iterations</label>
            <input type="number" id="iterations-{test_id}" name="iterations" class="form-control" 
                   value="1000" min="1" max="100000">
        </div>
        
        <div class="input-group">
            <label for="timeout-{test_id}">Timeout (ms)</label>
            <input type="number" id="timeout-{test_id}" name="timeout" class="form-control" 
                   value="5000" min="100" max="30000">
        </div>
        """

    def _create_security_inputs(self, test_case: Dict, test_id: str) -> str:
        """Create inputs for security tests"""
        return f"""
        <div class="input-group">
            <label for="sql-injection-{test_id}">SQL Injection Test</label>
            <input type="text" id="sql-injection-{test_id}" name="sql_injection" class="form-control" 
                   placeholder="'; DROP TABLE users; --">
        </div>
        
        <div class="input-group">
            <label for="xss-test-{test_id}">XSS Test</label>
            <input type="text" id="xss-test-{test_id}" name="xss_test" class="form-control" 
                   placeholder="<script>alert('XSS')</script>">
        </div>
        
        <div class="input-group">
            <label for="buffer-overflow-{test_id}">Buffer Overflow Test</label>
            <textarea id="buffer-overflow-{test_id}" name="buffer_overflow" class="form-control" 
                      placeholder="Enter very long string..."></textarea>
        </div>
        """

    def _create_general_inputs(self, test_case: Dict, test_id: str) -> str:
        """Create general purpose inputs"""
        return f"""
        <div class="input-group">
            <label for="param1-{test_id}">Parameter 1</label>
            <input type="text" id="param1-{test_id}" name="param1" class="form-control" 
                   placeholder="Enter first parameter">
        </div>
        
        <div class="input-group">
            <label for="param2-{test_id}">Parameter 2</label>
            <input type="text" id="param2-{test_id}" name="param2" class="form-control" 
                   placeholder="Enter second parameter">
        </div>
        
        <div class="input-group">
            <label for="expected-{test_id}">Expected Result</label>
            <input type="text" id="expected-{test_id}" name="expected" class="form-control" 
                   placeholder="Enter expected result">
        </div>
        """

    def _generate_validation_script(self, test_case: Dict, function_name: str) -> str:
        """Generate JavaScript validation script for test case"""

        test_id = test_case.get('test_id')
        category = test_case.get('category', 'general')

        return f"""
        function executeTest_{test_id}(event) {{
            event.preventDefault();
            
            const testContainer = document.getElementById('test-{test_id}');
            const resultsDiv = document.getElementById('results-{test_id}');
            const form = event.target;
            
            // Collect form data
            const formData = new FormData(form);
            const testData = Object.fromEntries(formData.entries());
            
            // Show results section
            resultsDiv.style.display = 'block';
            
            // Execute test based on category
            let result;
            try {{
                result = execute{category.title().replace('_', '')}Test(testData, '{function_name}');
            }} catch (error) {{
                result = {{
                    success: false,
                    error: error.message,
                    timestamp: new Date().toISOString()
                }};
            }}
            
            // Display results
            displayTestResult('{test_id}', result);
            
            return false;
        }}
        
        function execute{category.title().replace('_', '')}Test(testData, functionName) {{
            // Category-specific test execution logic
            const startTime = performance.now();
            
            // Simulate function execution (in real implementation, this would call actual function)
            const mockResult = simulateFunction{category.title().replace('_', '')}(testData, functionName);
            
            const endTime = performance.now();
            const executionTime = endTime - startTime;
            
            return {{
                success: mockResult.success,
                result: mockResult.result,
                executionTime: executionTime,
                testData: testData,
                timestamp: new Date().toISOString()
            }};
        }}
        
        function simulateFunction{category.title().replace('_', '')}(testData, functionName) {{
            // Mock function execution - replace with actual function calls
            return {{
                success: true,
                result: `Mock result for ${{functionName}} with data: ${{JSON.stringify(testData)}}`
            }};
        }}
        
        window.executeTest = window.executeTest || function(testId, event) {{
            if (testId === '{test_id}') {{
                return executeTest_{test_id}(event);
            }}
        }};
        """

    async def _create_integration_test_suite(self, integration_tests: List[Dict]) -> Dict:
        """Create test suite for integration tests"""
        return {
            'suite_id': str(uuid.uuid4()),
            'suite_name': 'Integration Tests',
            'type': 'integration',
            'test_count': len(integration_tests),
            'test_cases': integration_tests,
            'html_forms': []  # Would be implemented similar to function tests
        }

    async def _create_performance_test_suite(self, performance_tests: List[Dict]) -> Dict:
        """Create test suite for performance tests"""
        return {
            'suite_id': str(uuid.uuid4()),
            'suite_name': 'Performance Tests',
            'type': 'performance',
            'test_count': len(performance_tests),
            'test_cases': performance_tests,
            'html_forms': []
        }

    async def _create_security_test_suite(self, security_tests: List[Dict]) -> Dict:
        """Create test suite for security tests"""
        return {
            'suite_id': str(uuid.uuid4()),
            'suite_name': 'Security Tests',
            'type': 'security',
            'test_count': len(security_tests),
            'test_cases': security_tests,
            'html_forms': []
        }
